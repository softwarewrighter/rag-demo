# Learnings from Development Issues

This document captures issues encountered during development and provides proactive strategies to prevent them in future AI agent coding sessions.

## Issues Encountered and Resolutions

### 1. Documentation Comment Style (clippy::empty-line-after-doc-comments)

**Issue**: Empty line between module documentation and function documentation
```rust
// INCORRECT
/// Module documentation
/// continues here

/// Function documentation
pub fn foo() {}
```

**Resolution**: Use inner doc comments (`//!`) for module-level documentation
```rust
// CORRECT
//! Module documentation
//! continues here

/// Function documentation
pub fn foo() {}
```

**Proactive Prevention**:
- Always use `//!` for module/crate-level documentation
- Use `///` only for documenting the item immediately following
- No empty lines between doc comment and documented item

### 2. Unused Imports

**Issue**: Imported `std::path::Path` but never used it
```rust
use std::path::Path;  // Never actually used
```

**Resolution**: Remove unused imports

**Proactive Prevention**:
- Only add imports when actually using them in code
- After refactoring, scan for and remove unused imports
- Run `cargo check` frequently during development to catch these early

### 3. Needless Borrows in Generic Arguments (clippy::needless-borrows-for-generic-args)

**Issue**: Unnecessary borrowing when passing arrays to functions
```rust
// INCORRECT
Args::parse_from(&["proact", "arg"]);
```

**Resolution**: Remove the borrow
```rust
// CORRECT
Args::parse_from(["proact", "arg"]);
```

**Proactive Prevention**:
- Arrays and slices often don't need explicit borrowing in generic contexts
- When passing literals to generic functions, try without `&` first
- Trust clippy's suggestions for borrowing patterns

### 4. Uninlined Format Arguments (clippy::uninlined-format-args)

**Issue**: Using positional arguments in format strings
```rust
// INCORRECT
format!("Generated by: {}", project_name)
```

**Resolution**: Use inline variable names
```rust
// CORRECT
format!("Generated by: {project_name}")
```

**Proactive Prevention**:
- Always use inline format arguments when variables are available
- This makes code more readable and less error-prone
- Applies to `format!`, `println!`, `eprintln!`, etc.

### 5. Edition Specification

**Issue**: Used incorrect edition specification

**Resolution**: Use `edition = "2024"` (the latest stable edition as of 2025)

**Proactive Prevention**:
- Always use stable Rust editions: "2015", "2018", "2021", or "2024"
- Check current stable edition before specifying
- Default to "2024" for new projects to get latest language features
- Note: Rust 2024 edition was stabilized in late 2024

## General Patterns and Best Practices

### Always Run the Checkpoint Sequence

Before considering any task complete:
1. `cargo clippy --all-targets --all-features -- -D warnings`
2. `cargo fmt`
3. `cargo test`

This catches issues early and ensures code quality.

### Clippy Configuration Recommendations

For AI agents working with Rust, always use strict clippy settings:
```bash
cargo clippy --all-targets --all-features -- -D warnings
```

This treats all warnings as errors, forcing immediate resolution.

### Import Management Strategy

1. Start with minimal imports
2. Add imports only as needed
3. After refactoring, audit imports
4. Let the compiler guide you - missing imports produce clear errors

### Documentation Comments Best Practices

1. **Module/Crate docs**: Use `//!` at the top of the file
2. **Item docs**: Use `///` immediately before the item
3. **No empty lines**: Between doc comment and documented item
4. **Complete sentences**: End with periods
5. **Examples when helpful**: Use doc tests for usage examples

### Format String Evolution

Modern Rust prefers inline format arguments:
- ❌ `format!("{} {}", foo, bar)`
- ✅ `format!("{foo} {bar}")`
- ✅ `format!("{name}: {value}")`

This applies to all formatting macros.

## Proactive AI Agent Guidelines

### Before Writing Code
1. Check Rust edition compatibility
2. Plan module structure to minimize circular dependencies
3. Consider which traits need to be imported

### While Writing Code
1. Use inline format arguments from the start
2. Apply correct doc comment style immediately
3. Only import what's immediately needed
4. Run `cargo check` frequently (every few functions)

### Before Checkpoint
1. Run `cargo clippy` with strict settings
2. Address all warnings before proceeding
3. Run `cargo fmt` to ensure consistent style
4. Run `cargo test` to verify functionality
5. Do a final import audit

### Common Clippy Warnings to Anticipate

- `needless_borrows_for_generic_args` - Don't over-borrow
- `uninlined_format_args` - Use inline format syntax
- `unused_imports` - Remove after refactoring
- `empty_line_after_doc_comments` - Proper doc comment placement
- `redundant_field_names` - Use field init shorthand

## Test Output Management

### Best Practice: Gitignored Test Directories

**Issue**: Tests were cleaning up after themselves, making it hard to debug failures
**Resolution**: Use gitignored test output directories that persist after test runs

**Implementation**:
```rust
// Setup function removes OLD artifacts, creates fresh directory
fn setup_test_dir(test_name: &str) -> PathBuf {
    let dir = get_test_dir(test_name);
    let _ = fs::remove_dir_all(&dir);  // Clean BEFORE test
    fs::create_dir_all(&dir).unwrap();
    dir
}

// Tests end with: // No cleanup - leave for inspection
```

**Benefits**:
- Test failures leave artifacts for debugging
- Can inspect generated files after test runs
- Each test run starts fresh (pre-test cleanup)
- No pollution of version control (gitignored)

**Gitignore Pattern**:
```
/test-output/
/tmp-test-*
```

## Feature Implementation: Dry-Run Mode

### Implementation Approach
When adding the `-n/--dry-run` feature, the following design decisions were made:

1. **Dry-run implies verbose**: Users running dry-run always want to see what would happen
2. **Verbose shows actual operations**: Both verbose and dry-run modes now show file operations in shell-command format
3. **Conditional execution**: Used `if !args.dry_run` guards around actual file operations
4. **Clear user feedback**: Different messages for dry-run vs actual execution

### File Operation Logging Format
- Directory creation: `mkdir -p <path>`
- File writing: `write <path> (<size> bytes)`
- Existing directory: `# Directory already exists: <path>`

This format is familiar to developers and clearly indicates what operations would be performed.

## Critical Bug: Output Directory Location

### The Issue
**Bug**: The program was writing documentation to `./docs` or the specified `-o` directory relative to the current working directory, completely ignoring the TARGET argument.

**Expected Behavior**: Documentation should be written to `<TARGET>/docs` or `<TARGET>/<output-dir>`.

**Impact**: Users would find their documentation in the wrong location, not in their target project directory.

### Root Cause
The implementation was using `args.output_dir` directly instead of joining it with the target path. This meant:
- `proact ../my-project` would create `./docs/` instead of `../my-project/docs/`
- `proact -o custom ../my-project` would create `./custom/` instead of `../my-project/custom/`

### The Fix
```rust
// BEFORE - Wrong!
let output_file = args.output_dir.join("ai_agent_instructions.md");

// AFTER - Correct!
let output_dir = if args.output_dir.is_absolute() {
    args.output_dir.clone()
} else {
    args.target.join(&args.output_dir)  // Join with target!
};
let output_file = output_dir.join("ai_agent_instructions.md");
```

### Proactive Prevention
1. **Always test with different directory structures** - Don't just test in the current directory
2. **Write integration tests first** - They catch these architectural issues
3. **Question assumptions** - "Where should output go?" should be explicitly defined
4. **Think about user expectations** - Users expect output in their project, not the tool's CWD

### Additional Feature: Learnings.md Management
While fixing this, also added:
- Automatic copying of `learnings.md` to target project
- Append mode with timestamp separator for existing learnings files
- This ensures knowledge is propagated to projects using the tool

## Continuous Improvement

Each time a new pattern of issue is discovered:
1. Document it in this file
2. Add to the proactive prevention strategies
3. Consider if it should be added to the generated AI agent documentation
4. Update templates if it's a common pattern across languages

By following these guidelines, AI agents can produce higher quality code on the first attempt, reducing the need for correction cycles and improving overall development efficiency.